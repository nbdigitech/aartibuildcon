<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0087)http://gatexcel.co.in/public/code/tce_show_result_user.php?testuser_id=92326&test_id=57 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Test Results</title>

<meta name="language" content="en">
<meta name="tcexam_level" content="1">
<meta name="description" content="[TCExam] TCExam by Tecnick.com [Raudra Exam (c) 2019]">
<meta name="author" content="nick">
<meta name="reply-to" content="">
<meta name="keywords" content="TCExam, eExam, e-exam, web, exam">
<link rel="stylesheet" href="./Test Results122_files/jquery-ui.css">
<link rel="stylesheet" href="./Test Results122_files/calclayout.css">
<script src="./Test Results122_files/jquery-1.12.4.js.download"></script>
<script src="./Test Results122_files/jquery-ui.js.download"></script>
<script src="./Test Results122_files/jquery.dialogextend.min.js.download"></script>
<script src="./Test Results122_files/custom.js.download"></script>
<script src="./Test Results122_files/oscZenoedited.js.download"></script>
<link rel="stylesheet" href="./Test Results122_files/default.css" type="text/css">
<link rel="shortcut icon" href="http://gatexcel.co.in/favicon.ico">
</head>
<body>
<div class="header">
<div class="left"></div>
<div class="right">
<a name="timersection" id="timersection"></a>
<form action="http://gatexcel.co.in/public/code/tce_show_result_user.php" id="timerform">
<div>
<input type="text" name="timer" id="timer" value="" size="29" maxlength="29" title="Clock / Timer" readonly="readonly">
&nbsp;</div>
</form>
<script src="./Test Results122_files/timer.js.download" type="text/javascript"></script>
<script type="text/javascript">
//<![CDATA[
FJ_start_timer(false, 1486921376, 'I\'m sorry, the time available to complete the test is over!', false, 1486921376050);
//]]>
</script>
</div>
</div>
<div id="scrollayer" class="scrollmenu">
<!--[if lte IE 7]>
<style type="text/css">
ul.menu li {text-align:left;behavior:url("../../shared/jscripts/IEmen.htc");}
ul.menu ul {background-color:#003399;margin:0;padding:0;display:none;position:absolute;top:20px;left:0px;}
ul.menu ul li {width:200px;text-align:left;margin:0;}
ul.menu ul ul {display:none;position:absolute;top:0px;left:190px;}
</style>
<![endif]-->
<a name="menusection" id="menusection"></a>
<div class="hidden"><a href="http://gatexcel.co.in/public/code/tce_show_result_user.php?testuser_id=92326&amp;test_id=57#topofdoc" accesskey="2" title="[2] skip navigation menu">skip navigation menu</a></div>
<ul class="menu">
<li><a href="http://gatexcel.co.in/public/code/index.php" title="Main Page" id="Main Page" accesskey="i">Home</a></li>
<li><a href="http://gatexcel.co.in/public/code/tce_page_user.php" title="User" id="User" accesskey="u">User</a>
<!--[if lte IE 6]><iframe class="menu"></iframe><![endif]-->
<ul>
<li><a href="http://gatexcel.co.in/public/code/tce_user_change_email.php" title="Change Email" id="Change Email">Change Email</a></li>
<li><a href="http://gatexcel.co.in/public/code/tce_user_change_password.php" title="Change Password" id="Change Password">Change Password</a></li>
</ul>
</li>
<li><a href="http://gatexcel.co.in/public/code/tce_logout.php" title="click on this link to exit the system (session end)" id="click on this link to exit the system (session end)" accesskey="q">Logout</a></li>
</ul>
</div>
<div class="body">
<a name="topofdoc" id="topofdoc"></a>
<script>
    $(document).ready(function(){
   
       // $('#numBox').click(function(){
        $('#keypad').fadeToggle('fast');
        event.stopPropagation();
  //  });
    
    
  
    $('.key').click(function(){
        var numBox = document.getElementById('answertext');
//        if(this.innerHTML == '0'){
//            if (numBox.value.length > 0 && numBox.value.length<11)
//                numBox.value = numBox.value + this.innerHTML;
//        }
//        else 
      if(numBox.value.length<11){
        if(this.innerHTML == '-'){
            if (numBox.value.length == 0)
                numBox.value = numBox.value + this.innerHTML;
        }
        else if(this.innerHTML == '.'){
            console.log(numBox.value.indexOf('-'));
            if(numBox.value.length == 1){                
            }else{
                if(numBox.value.indexOf('.') == -1)
                 numBox.value = numBox.value + this.innerHTML;
            }
        }
        else{
        
            numBox.value = numBox.value + this.innerHTML;
        }
    }
        event.stopPropagation();
    });
    
    $('.btn').click(function(){
          var numBox = document.getElementById('answertext');
        if(this.innerHTML == 'Backspace'){           
            if(numBox.value.length > 0){
                numBox.value = numBox.value.substring(0, numBox.value.length - 1);
            }
        }
        else if(this.innerHTML == '←'){
          var current_position = numBox.value.slice(0, numBox.selectionStart).length;
          if(current_position != 0){
              numBox.setSelectionRange(current_position-1,current_position-1);
          }
           numBox.focus();
        }
        else if(this.innerHTML == '→'){
           var current_position = numBox.value.slice(0, numBox.selectionStart).length;
           
           if(current_position != numBox.value.length){
              numBox.setSelectionRange(current_position+1,current_position+1);
          }
           numBox.focus();
        }
        else{
            document.getElementById('answertext').value = '';
        }
        
        event.stopPropagation();
    });
    });
    
    function validateNumeric(e) {        
    if (!e) var e = window.event;
    if (!e.which) keyPressed = e.keyCode;
    else keyPressed = e.which;
   
    if ((keyPressed >= 48 && keyPressed <= 57) ||keyPressed == 45 || keyPressed == 46 || keyPressed == 8 || keyPressed == 9 || (keyPressed > 37 && keyPressed <= 40)) {
      keyPressed = keyPressed;
      var text = $("#answertext").val();
      if(keyPressed ==  46){
         if(text.indexOf(".") > -1){
              return false;
          }
      }
    
       if(keyPressed ==  45){             
             if(text.length == 0){
              return true;
            }else{
                return false;
            }
        }
        if(keyPressed ==  46){             
             if(text.length == 0){
              return true;
            }else{
             if(text.length==1){
                if(text.indexOf("-") == "0"){
                        return false;
                  }
                 }
                return true;
            }
        }
      return true;
    } else {
      keyPressed = 0;
      return false;
    }
  }
  
</script><div class="container">
<div class="tceformbox">
<div class="row">
<span class="label">
<span title="User">User:</span>
</span>
<span class="formw">
 abhi.sinu.1 - abhi.sinu.1&nbsp;
</span>
</div>
<div class="row">
<span class="label">
<span title="Test">Test:</span>
</span>
<span class="formw">
<strong>CD Subject Test 3</strong><br>
Compiler Design Complete Syllabus&nbsp;
</span>
</div>
<div class="row">
<span class="label">
<span title="test starting date and time [yyyy-mm-dd hh:mm:ss]">Start Time:</span>
</span>
<span class="formw">
2017-02-11 23:39:27&nbsp;
</span>
</div>
<div class="row">
<span class="label">
<span title="test ending date and time [yyyy-mm-dd hh:mm:ss]">End Time:</span>
</span>
<span class="formw">
&nbsp;
</span>
</div>
<div class="row">
<span class="label">
<span title="Test Time">Test Time:</span>
</span>
<span class="formw">
01:30:00&nbsp;
</span>
</div>
<div class="row">
<span class="label">
<span title="Final Score">Points:</span>
</span>
<span class="formw">
0.000 / 50.000 (0%)&nbsp;
</span>
</div>
<div class="row">
<span class="label">
<span title="Correct Answers">Correct:</span>
</span>
<span class="formw">
0 / 33 (0%)&nbsp;
</span>
</div>
<div class="rowl">
<ol class="question">
<li>
‘Divide by zero’ is a<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Lexical error</li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> Runtime error<br><span class="explanation">Explanation:</span><br>Runtime errors occur when a program with no syntax errors asks the computer to do something that the computer is unable to reliably do.  Common examples are:<br>•	Trying to divide by a variable that contains a value of zero<br>•	Trying to open a file that doesn't exist<br>There is no way for the compiler to know about these kinds of errors when the program is compiled.
</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> None of these</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Syntax error</li>
</ol>
<br><br>
</li>
<li>
The two basic operations that are often performed with the symbol table are:<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Set and insert</li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> Insert and lookup<br><span class="explanation">Explanation:</span><br>Insert and lookup are two basic operation performed by symbol table. Insert- adds new entries while lookup- find existing entries. Every time the compiler finds a new identifier in the source code during the lexical analysis phase, it needs to check if that identifier is in the table, if not it needs to store it there. Every insertion operation is always preceded with search operation during lexical analysis phase.
</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Reset and lookup</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Set and reset</li>
</ol>
<br><br>
</li>
<li>
The grammar<br>S → aSb | SS | ∊ is ambiguous as it has:<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> All of these</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Two RMD’s for ‘ab’</li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> Two LMD’s for ‘ab’ and two RMD’s for ‘ab’<br><span class="explanation">Explanation:</span><br><img src="./Test Results122_files/Q2_exp.PNG" alt="image:CD Subject Test - 3/Q2_exp.PNG" width="522" height="346" class="tcecode"><br>This leads to the grammar being ambiguous. However even if any one of the options would have occurred the grammar would have been ambiguous.
</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> One LMD and one RMD for ‘ab’</li>
</ol>
<br><br>
</li>
<li>
The DAG for the following statement is:<br>a = (b + c) + (d – c) + a / (d – c) + (b + c)<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> <img src="./Test Results122_files/Q20_opt_C.PNG" alt="image:CD Subject Test - 3/Q20_opt_C.PNG" width="245" height="202" class="tcecode"></li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> <img src="./Test Results122_files/Q20_opt_A.PNG" alt="image:CD Subject Test - 3/Q20_opt_A.PNG" width="191" height="321" class="tcecode"><br><span class="explanation">Explanation:</span><br>Algorithm for construction of DAG:<br>In construction process of DAG we process each statement and categorize it to one of the following cases:<br>i.	a = b op c<br>ii.	a = op b<br>iii.	a = b<br>iv.	Relational operators are treated as case(i) for example if i ≤ 20 goto l1¬ considered similar to case (ii) with ‘a’ undefined.<br>Initially we assume there are no nodes, and a node is undefined for all arguments and does the following steps:<br>1.	For case(i)<br>a.	If node(b) and node(c) are undefined, create leafs labeled ‘b’ and ‘c’ respectively; let node(b) and node(c) be these nodes.<br>b.	Find if there is a node labeled op, with left child as node(b) and right child as node(c); if found return this node; otherwise, create a node and let this be ‘n’.<br>c.	Delete ‘a’ from the list of attached identifiers for node(a). Append ‘a’ to the list of attached identifiers for the node n found in (b) and set node(a) to n.<br>2.	For case(ii)<br>a.	If node(a) is undefined, create a leaf labeled ‘b;; let node(b) be the node.<br>b.	Find if there is a node labeled op, whose lone child is node(b); if so, return this node otherwise create a node and let this be ‘n’.<br>c.	Delete ‘a’ from the list of attached identifiers for node(a). Append ‘a’ to the list of attached identifiers for the node n found in (b) and set node(a) to n.<br>3.	For case(iii)<br>a. node(b) is an existing node and let it be n.<br>b. Delete ‘a’ from the list of attached identifiers for node(a). Append ‘a’ to the list of attached identifiers for the node n found in (a) and set node(a) to n.<br><br>So following the above algorithm we get the below DAG:<br><img src="./Test Results122_files/Q20_exp.PNG" alt="image:CD Subject Test - 3/Q20_exp.PNG" width="320" height="347" class="tcecode">
</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> None of these</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> <img src="./Test Results122_files/Q20_opt_B.PNG" alt="image:CD Subject Test - 3/Q20_opt_B.PNG" width="192" height="250" class="tcecode"></li>
</ol>
<br><br>
</li>
<li>
Let the SDT be:<br>	S → AB {A.S = B.S}<br>	The above SDT is<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> None of these<br><span class="explanation">Explanation:</span><br>Not S-attributed as it is using the value from its parent.<br>	Not L-attributed as it is using the right sibling.
</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Both of them</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> L-attributed</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> S-attributed</li>
</ol>
<br><br>
</li>
<li>
If a symbol is implemented using hierarchical list then the performance is proportional to:<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> n<sup class="tcecode">2</sup></li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> n</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> n logn</li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> (m + n) log n<br><span class="explanation">Explanation:</span><br>Binary search tree is a more efficient approach to symbol table organization. First the name is searched in the tree if it exists, then it is ignored. If it does not exist, then a new record is created for the new name and is inserted as a leaf node. This organization follows a lexicographical order, that is, all the names accessible from namei with value less than namei are found by following a left link. Similarly, all the names accessible from namei that follow namei in alphabetical order are found by following the right link. The expected time needed to enter n names and to make m queries is proportional to (m + n)log2n. So for a greater number of records (higher n), this method had advantages over linear list organization.
</li>
</ol>
<br><br>
</li>
<li>
Consider the NFA given below:<br>           <img src="./Test Results122_files/Q1.PNG" alt="image:CD Subject Test - 3/Q1.PNG" width="544" height="215" class="tcecode"><br>	What is the language accepted by the above NFA:<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> L= {w | w contains either a pair of b’s separated by exactly 2n + 2 consecutive a’s (for some n ≥ 1), or a pair of a’s separated by exactly 2m + 1 consecutive b’s (for some m ≥ 1)}<br><span class="explanation">Explanation:</span><br>The above NFA for the set of strings over the alphabet ∑ = {a, b} which contain either a pair of b’s separated by exactly 2n + 2 consecutive a’s (for some n ≥ 1) or a pair of a’s separated by exactly 2m + 1 consecutive b’s (for some m ≥ 1).<br>Eg of strings that should be accepted by this NFA:<br>	aaabbba, baaaaba, ababaaaaaab.<br>Eg of strings that should not be accepted:<br>	 abbbba, ababaaab, aba.
</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> L = {w | w contains either at least a pair of a’s ending with b or at least three b’s ending with a}</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> L = {w | w ends either with b or a}</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> None of these</li>
</ol>
<br><br>
</li>
<li>
Consider the LR(0), LR(k), LR(1) and SLR(1) grammars then which of the following about these grammar is true?<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> SLR(1) ⊂ LR(0) ⊂ LR(1) ⊂ LR(k)</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> LR(k) ⊂ LR(0) ⊂ LR(1) ⊂ SLR(1)</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> LR(0) ⊂ LR(k) ⊂ LR(1) ⊂ SLR(1)</li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> LR(0) ⊂ SLR(1) ⊂ LR(1) ⊂ LR(k)<br><span class="explanation">Explanation:</span><br>LR(0) is a superset of SLR(1). Both of them just differ in the placement of reduce moves.<br>Because of the addition of lookaheads LR(1) is a better parser compared to first two.<br>		LR(k) is a subset of LR(1) parser.
</li>
</ol>
<br><br>
</li>
<li>
Consider the input string ‘a + b * c’ is being parsed by an operator precedence parser. At a certain instance the stack pointer and the pointer in the i/p buffer is shown as below<br><br><img src="./Test Results122_files/Q6.PNG" alt="image:CD Subject Test - 3/Q6.PNG" width="199" height="91" class="tcecode"><br>What is the action taken by the operator precedence parser at this instance?<br><br>Note: Given: $  &lt;∙  a,   a  ∙&gt;  +,    $  &lt;∙  +,    +  &lt;∙  b,    b  &lt;∙  *,    +  ∙&gt;  *,      *  &lt;∙  c,          c  &lt;∙  $,    *  &lt;∙  $,     +  &lt;∙  $.<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> Shift * because + ∙&gt;  *<br><span class="explanation">Explanation:</span><br>1.Initially, stack contains only $ and input buffer contains w$ where w is input string<br>2.Repeat forever<br>a.Let “a” be the top element on stack and “b” is the current element pointed by the input pointer, that is, the look ahead symbol<br>b.If a &lt; b or a = b, push b onto the stack and increment input pointer.(shift action)<br>c.If a &gt; b then (reduce action) repeat Pop the stack until the top of the stack is &lt; to the terminal most recently popped<br>d.If a = b = $, announces successful completion<br><img src="./Test Results122_files/Q6_exp.PNG" alt="image:CD Subject Test - 3/Q6_exp.PNG" width="557" height="332" class="tcecode">
</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Shift * because *  ∙&gt;  +</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Pop * because *  &lt;∙  $</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Cannot be determined</li>
</ol>
<br><br>
</li>
<li>
Consider the grammar below:<br>P → ( op C<br>C → ) | EC<br>E → ( op C | id<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> The grammar is not LR(0)</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> The grammar is not SLR(1)</li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> The grammar is both LR(0) &amp; SLR(1)<br><span class="explanation">Explanation:</span><br>We augment the grammar with the transition S → P	.The canonical collection of LR(0) items is given as follows:<br>	 <img src="./Test Results122_files/Q17_exp.PNG" alt="image:CD Subject Test - 3/Q17_exp.PNG" width="652" height="416" class="tcecode"><br>No state contains both productions of form A → α ∙ αβ and productions of the form B → γ ∙ , so no shift reduce conflict exists. All states containing productions of the form B → γ ∙ contain only one such production, and thus no reduce-reduce conflict exist.
</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> The grammar is neither LR(0) nor SLR(1)</li>
</ol>
<br><br>
</li>
<li>
Consider the following statement in context of LR parser:<br>I.	LR parser can be constructed to recognize virtually all programming language<br>construct for which context free grammar can be written.<br>II.	LR parser method is most general non backtracking shift reduce parsing method known.<br>III.	The class of grammar that can be parsed using LR method is proper superset of class of grammar that can be parsed with predictive parsers.<br>IV.	LR parser cannot detect syntactic error. <br>Which one of the following is true?<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> (I) is false but (II) (III) and (IV) is correct</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> (I) (II) are false but (III) (IV) is correct</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> (I) (II) (III) and (IV) are correct</li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> (I) (II) and (III) only are correct<br><span class="explanation">Explanation:</span><br>I.	Programming languages which can be written in CFG can be parsed by LR parsers in linear time.<br><br>II.	LR parsers are non backtracking and they parse on shift and reduce principle. Shift-reduce parsing attempts to construct a parse tree for an input string beginning at the leaves and working up towards the root. In other words, it is a process of “reducing” (opposite of deriving a symbol using a production rule) a string w to the start symbol of a grammar.<br><br>III.	 LR parsing is most general non-back tracking shift reduce parsing. The class of grammars that can be parsed using LR methods is a proper superset of the class of grammars that can be parsed with predictive parsers <br>LL (1) grammars ⊆ LR (1)) grammars<br><br><br>IV.	An LR parser can detect a syntactic error as soon as it is possible to do so on a left-to-right scan of the input.
</li>
</ol>
<br><br>
</li>
<li>
Consider the following SDD:<br>A → A<sub class="tcecode">1</sub>Y{A.a = g(A<sub class="tcecode">1</sub>.a, Y.y)}<br>A → X{A.a = f(X.x)}<br>Where f and g take as arguments whatever attributes they are allowed to access. Which one of the following is correct?<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> It contains only synthesized attributes<br><span class="explanation">Explanation:</span><br>Here, A.a is the synthesized attribute of left-recursive non-terminal A, and X and Y are single grammar symbols with synthesized attributes X.x and Y.y respectively. These could represent a string of several grammar symbols, each with its own attribute(s), since the schema has an arbitrary function g computing A.a in the recursive production and an arbitrary function f computing A.a in the second production. In each case, f and g take as arguments whatever attributes they are allowed to access if the SDD is S-attributed.
</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> It contains both of them</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> It contains only L-attributed definitions</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> It does not contain left recursion</li>
</ol>
<br><br>
</li>
<li>
Consider the following relation table:<br><img src="./Test Results122_files/Q7.PNG" alt="image:CD Subject Test - 3/Q7.PNG" width="379" height="186" class="tcecode"><br>Which one is the precedence function table for the above Relation table?<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> <img src="./Test Results122_files/Q7_opt_a.PNG" alt="image:CD Subject Test - 3/Q7_opt_a.PNG" width="457" height="74" class="tcecode"><br><span class="explanation">Explanation:</span><br>:<br>There are four terminals id, *, + and $; hence, create 8 symbols fid, gid, f+, g+, f*, g*, f$ and g$. As there are no ≐ relations, each symbol is treated as a separate group. Now construct diagraph as shown in figure with each symbol as a node, that is, 8 nodes as follows.<br>To get the precedence function f(id), start from node fid, traverse all possible paths from fid. The path must start with fid and can end anywhere (need not be f$ or g$).<br>For example, from node fid there are four possible paths as follows:<br>	f¬id – g$ where path length is 2<br>	fid – g* – f+ – g$ where path length is 3<br>	fid – g* – f+ – g+ – f$ where path length is 4<br>	fid – g+ – f$ where path length is 3<br><img src="./Test Results122_files/Q7_exp.PNG" alt="image:CD Subject Test - 3/Q7_exp.PNG" width="559" height="467" class="tcecode">
</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> <img src="./Test Results122_files/Q7_opt_c.PNG" alt="image:CD Subject Test - 3/Q7_opt_c.PNG" width="464" height="73" class="tcecode"></li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> None of these</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> <img src="./Test Results122_files/Q7_opt_b.PNG" alt="image:CD Subject Test - 3/Q7_opt_b.PNG" width="465" height="74" class="tcecode"></li>
</ol>
<br><br>
</li>
<li>
Choose the false statements<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> LL(K) grammar has to be a CFG</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> LL(K) grammars cannot have recursive non-terminals</li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> There are LL(K) grammars that are not context free<br><span class="explanation">Explanation:</span><br>LL(K) grammars has to be CFG. It can also be regular since all regular grammars can also be context free.<br>Any ambiguous grammar cannot be LL(K) grammar since LL(K) grammars are top down parsers so having left recursion leads to infinite loop.
</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> LL(K) grammar has to be a unambiguous</li>
</ol>
<br><br>
</li>
<li>
A program can contain errors at different level like,<br>(1)	Lexical such as misspelling an identifier, keyword or operator.<br>(2)	Syntactic such as arithmetic expression with unbalanced parenthesis<br>(3)	Adding a array variable and function variable<br>In which one of the following phases of compiler, the program will be free from all the above errors?<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Syntax analysis phase</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Lexical analysis phase</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> None of these</li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> Semantic analysis phase<br><span class="explanation">Explanation:</span><br>After all the lexical errors, syntax errors and semantic errors are removed. The code is given for intermediate code generator which do not have any errors.<br>The later stages also (which are CO &amp; TCG) are targeted for converting the code into assembly level and no more error recovery occurs.
</li>
</ol>
<br><br>
</li>
<li>
Which of the following grammar is LR(1)?<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> S → aSb, S → bSb, S → a, S → b</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> S → aSa, S → aSb, S → c</li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> Both (a) and (b)<br><span class="explanation">Explanation:</span><br>The canonical collection of LR(1) items for the grammar given below is:<br><img src="./Test Results122_files/Q13_exp_1.PNG" alt="image:CD Subject Test - 3/Q13_exp_1.PNG" width="233" height="184" class="tcecode"><br><img src="./Test Results122_files/Q13_exp_2.PNG" alt="image:CD Subject Test - 3/Q13_exp_2.PNG" width="560" height="497" class="tcecode"><br>We can see that there are no conflicts i.e neither Shift reduce nor Reduce reduce so the above grammar is LR(1)<br>The cannonical collection of LR(1) items for the grammar given below is:<br><img src="./Test Results122_files/Q13_exp_3.PNG" alt="image:CD Subject Test - 3/Q13_exp_3.PNG" width="297" height="146" class="tcecode"><br><img src="./Test Results122_files/Edit_3.png" alt="image:CD Subject Test - 3/Edit_3.png" width="617" height="430" class="tcecode"><br>For the above collection of canonical LR(1) items also we can see there are no conflicts so the grammar is LR(1)
</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Neither (a) nor (b)</li>
</ol>
<br><br>
</li>
<li>
A s-attributed SDD for the grammar defined below for generating a decimal number from a binary number with a “decimal” point is given as:<br>	<img src="./Test Results122_files/Q31.PNG" alt="image:CD Subject Test - 3/Q31.PNG" width="198" height="73" class="tcecode"><span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> <img src="./Test Results122_files/Q31_opt_C.PNG" alt="image:CD Subject Test - 3/Q31_opt_C.PNG" width="348" height="118" class="tcecode"></li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> None of these</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> <img src="./Test Results122_files/Q31_opt_A.PNG" alt="image:CD Subject Test - 3/Q31_opt_A.PNG" width="401" height="180" class="tcecode"></li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> <img src="./Test Results122_files/Q31_opt_B.PNG" alt="image:CD Subject Test - 3/Q31_opt_B.PNG" width="501" height="119" class="tcecode"><br><span class="explanation">Explanation:</span><br>(*) The logic used in converting the integral part of the binary number to decimal is explained using an example<br><img src="./Test Results122_files/Q31_exp.PNG" alt="image:CD Subject Test - 3/Q31_exp.PNG" width="327" height="182" class="tcecode"><br><br>         (*)The logic used behind in converting the decimal part is explained using an  example:<br> Consider we need to convert   .101   from binary to decimal <br>So in general we use the following rule :<br>(1/2^1)*1+ (1/2^2)*0+(1/2^3)*1<br>which gives us 0.625<br>We are using the above weighted code method for evaluation but in a different way.<br>Here we take the highest power as common and get the following:<br>(1/2^3)(4*1+ 2*0 + 1*1) = 5/(2^3) = 5/8 = 0.625<br><br>Using the above two rules we associate the following semantic actions:<br><img src="./Test Results122_files/Q31_opt_B.PNG" alt="image:CD Subject Test - 3/Q31_opt_B.PNG" width="501" height="119" class="tcecode">
</li>
</ol>
<br><br>
</li>
<li>
Consider the following CFG, where the words in bold are terminals:<br>S →  S P | P<br>P  → L a T | and another A T | A T | T T D<br>D → duck<br>A → funny | little | fuzzy<br>L → here’s | there’s<br>T → llama<br>Which one of the following option is false?<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> The grammar is left recursive</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> The grammar is not left recursive but it is LL(1)</li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> The grammar is left recursive but not LL(1)<br><span class="explanation">Explanation:</span><br>Left recursion is of the form A → Aα | β<br>        The given grammar is left recursive because of the production :<br>	S  → SP <br>	Since the given grammar is left recursive so it can not be LL(1) since <br>LL(1) is a top down parser and presence of left recursion leads to infinite loop.
</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> The grammar is LL(1) but not left recursive</li>
</ol>
<br><br>
</li>
<li>
Consider the following grammar<br>E → E+T| T<br>T → T*F| F<br>F → id<br>There is a procedure mknode(l, d, r) where l is the left pointer, d is the data elements and r is the right pointer. There is an attribute nptr to denote the newly created node.  <br>What are the semantic rules that must be associated with the grammar so that it creates a syntax tree for the input “a+b*c”<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> E → E + T  {E.value = E.value + T.value;}<br>      E → T        {E.nptr = T.nptr;}<br>      T → T*F    {T.value = T.value*F.value;}<br>      T → F        {T.nptr = F.nptr}<br>      F → id        {F.nptr = mknode(NULL, id.lvalue, NULL);}</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> E → E + T  {E.nptr = mknode(E.nptr, “+”,T.nptr); E.value = E.value + T.value;}<br>      E → T        {E.value = T.value;}<br>      T → T*F    {T.nptr = mknode(T.nptr,”*”, F.nptr); T.value = T.value*F.value;}<br>      T → F        {T.value = F.value}<br>      F → id        {F.nptr = mknode(NULL, id.lvalue, NULL);}</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> None of these</li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> E → E + T  {E.nptr = mknode(E.nptr, “+”,T.nptr);}<br>       E → T        {E.nptr = T.nptr;}<br>       T → T*F    {T.nptr = mknode(T.nptr,”*”, F.nptr);}<br>       T → F        {T.nptr = F.nptr}<br>       F → id       {F.nptr = mknode(NULL, id.lvalue, NULL);}<br><span class="explanation">Explanation:</span><br>The first step is to define grammar. The grammar is already given:<br>E → E+T| T<br>T → T*F| F<br>F → id<br>		The second step is to take the input string and draw a parse tree<br><img src="./Test Results122_files/Q28_exp.PNG" alt="image:CD Subject Test - 3/Q28_exp.PNG" width="428" height="469" class="tcecode"><br>The first reduction is that identifier “a” is reduced to F. here we need to create a leaf node. For creating leaf nodes we use the mknode( ) function with the left pointer and the right pointer as NULL. The return type of function is the pointer to the newly created node. So to store this node pointer, assume that there is an attribute “nptr”. The semantic action is as follows:<br>			F → id		{F.nptr = mknode(NULL, id.value, NULL);}<br>The next reduction is F to T. here simply extend the pointer further to T by adding semantic action as<br>			T → f		{T.nptr = F.nptr;}<br>		Similarly, even for the next reduction T to E, extend the pointer further.<br>	The next reduction is “T*F” to T. here create a node using the mknode( ) function with “*” data element and T.nptr as the left pointer and F.nptr as the right pointer as shown below:<br>		T → T*F	{T.nptr = mknode(T.nptr, “*”, F.nptr);}<br>	The same thing can be carried out for E + T to E as<br>		E → E + T	{E.nptr = mknode(E.nptr, “+”, T.nptr);}	<br>The semantic rules to associated with the grammar to generate syntax trees is:<br>E → E + T  {E.nptr = mknode(E.nptr, “+”,T.nptr);}<br>E → T        {E.nptr = T.nptr;}<br>T → T*F    {T.nptr = mknode(T.nptr,”*”, F.nptr);}<br>T → F        {T.nptr = F.nptr}<br>F → id        {F.nptr = mknode(NULL, id.lvalue, NULL);}<br>So the SDT generated will be given as shown below :<br><img src="./Test Results122_files/Q28_exp_2.PNG" alt="image:CD Subject Test - 3/Q28_exp_2.PNG" width="233" height="176" class="tcecode">
</li>
</ol>
<br><br>
</li>
<li>
Consider the following program segment<br>fun length(x) = if null(x) then 0 else length(tl(x)+ + 1;<br>	The abstract syntax tree for the above code is:<br>	 Note: In order to implement any function use ‘apply’ eg: null(x) is represented as<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> <img src="./Test Results122_files/Q26_opt_A.PNG" alt="image:CD Subject Test - 3/Q26_opt_A.PNG" width="324" height="392" class="tcecode"></li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> <img src="./Test Results122_files/Edit_4.PNG" alt="image:CD Subject Test - 3/Edit_4.PNG" width="321" height="316" class="tcecode"><br><span class="explanation">Explanation:</span><br>The abstract syntax tree in figure represents the definition of length in figure. The root of the tree, labeled fun, represents the function definition. The remaining non leaf nodes can be viewed as function applications. The node labeled + represents the application of the operator + to a pair of children. Similarly, the node labeled if represents the application of an operator if to a triple formed by its children (for type checking, it does not matter that either the then or the else part will be evaluated, but not both).<br><img src="./Test Results122_files/Q26_exp.PNG" alt="image:CD Subject Test - 3/Q26_exp.PNG" width="361" height="347" class="tcecode"> <br>From the body of the function length, we can infer its type. Consider the children of the node labeled if, from left to right. Since null expects to be applied to lists, x must be a list. Let us use variable α as a placeholder for the type of the list elements, that is, x has type list of α.”<br>If null(x) is true, then length(x) is 0. Thus, the type of length must be “function from list of α to integer.” This inferred type is consistent with the usage of length in the else part, length(tl(x) + 1).
</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> <img src="./Test Results122_files/Q26_opt_B.PNG" alt="image:CD Subject Test - 3/Q26_opt_B.PNG" width="367" height="404" class="tcecode"></li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> None of these</li>
</ol>
<br><br>
</li>
<li>
Consider the following SDT:<br>S → while({L1 = new( ); L2 = new( ); C.false = S.next; c.true = L2;}<br>        C) {S<sub class="tcecode">1</sub>.next = L1;}<br>         S<sub class="tcecode">1</sub> {S.code = label || L1 || C.code || label || L2 || S<sub class="tcecode">1</sub>.code;}<br>	The above constructs used in SDT can be interpreted as:<br>•	The function new generates new labels.<br>•	The variables L1 and L2 hold labels that we need in the code. L1 is the beginning of the code for the while-statement, and we need to arrange that S1 jumps after it finishes. That is why we set S1.next to L1. L2 is the beginning of the code for S1, and it becomes the value of C.true, because we branch there when C is true.<br>•	Notice that C.false is set to S.next, because when the condition is false, we execute whatever code must follow the code for S.<br>•	We use || as the symbol for concatenation of intermediate code fragments. The value of S.code thus begins with the label L1, then the code for condition C, another label L2, and the code for S1.<br>	Which of the following is incorrect?<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> C.true labels the beginning of the code that must be executed if C is true.</li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> The SDT is L-attributed<br><span class="explanation">Explanation:</span><br>This SDD is L-attributed. When we convert it into an SDT, the only remaining issue is how to handle the labels L1 and L2, which are variables, and not attributes. If we treat actions as dummy non-terminals, then such variables can be treated as the synthesized attributes of dummy non-terminals. Since L1 and L2 do not depend on any other attributes, they can be assigned to the first action in the production. The resulting SDT with embedded actions that implements this L-attributed definition
</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> There are only inherited attributes and no synthesized attribute</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Since L1 and L2 are assigned to the first-action in the production hence the SDT is L-attributed</li>
</ol>
<br><br>
</li>
<li>
Consider the following statements :<br>	S1: While parsing the LL(1) parser keeps the leftmost symbol of RHS on top of the stack.<br>	S2: The least powerful parser is LR(0) while the most powerful parser is CLR(1)<br>	S3: SLR(1) has less no of reduce moves than LR(0)<br>Which of the above statement/s is/ are true?<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> S1, S2 and S3<br><span class="explanation">Explanation:</span><br><span style="text-decoration:underline;">Justification for S1:</span><br>LL(1) is a top down parser. <br><br>Top-down parsers start parsing from the start symbol. The strings are derived from the start symbol by repeatedly replacing a non-terminal (initially the start symbol) by the right side of a production, for that non-terminal. <br><br>Since we use stack as a data structure so objects are inserted and removed according to the last-in first-out (LIFO) principle. The leftmost symbol of RHS is the first symbol so it must be kept in the top of stack so that it can be parsed according to Top-down parser's way of parsing.<br><br><span style="text-decoration:underline;">Justification for S2:</span><br>From the diagram below we can see that CLR(1) has more power compared to other parser while LR(0) has the least<br><img src="./Test Results122_files/q33_exp.PNG" alt="image:CD Subject Test - 3/q33_exp.PNG" width="616" height="444" class="tcecode"><br> <br><span style="text-decoration:underline;">Justification for S3:</span><br>Since SLR(1) has less number of reduce moves compared to LR(0) this is the reason why SLR(1) is more powerful SLR(1) is more powerful as it detects errors faster compared to LR(0).
</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> None of these</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> S1 and S2</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Only S1</li>
</ol>
<br><br>
</li>
<li>
Consider the following statements:<br>S1: A syntax tree should not have keywords as leaves.<br>S2: A syntax tree is a condensed form of parse tree.<br>	Which of the above statement/s is/are true?<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Only S2</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Neither S1 nor S2</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Only S1</li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> Both S1 &amp; S2<br><span class="explanation">Explanation:</span><br>The parse tree is a concrete representation of the input. The parse tree retains all of the information of the input. The empty boxes represent white space, i.e. end of line. For example for some grammar this is the parse tree<br>             <img src="./Test Results122_files/Q27_exp_1.PNG" alt="image:CD Subject Test - 3/Q27_exp_1.PNG" width="574" height="548" class="tcecode"><br>AST<br>The AST is an abstract representation of the input. Notice that parents are not present in the AST because the associations are derivable from the tree structure. The syntax tree for the above grammar is given below:<br><img src="./Test Results122_files/Q27_exp_2.PNG" alt="image:CD Subject Test - 3/Q27_exp_2.PNG" width="218" height="233" class="tcecode">
</li>
</ol>
<br><br>
</li>
<li>
What is the output of the following program assuming that there are call by reference and dynamic scoping?<br><img src="./Test Results122_files/Q30.PNG" alt="image:CD Subject Test - 3/Q30.PNG" width="356" height="261" class="tcecode"><span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> 7, 24</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> 24, 7</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> 33, 3</li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> 20, 7<br><span class="explanation">Explanation:</span><br><img src="./Test Results122_files/Q30_exp.PNG" alt="image:CD Subject Test - 3/Q30_exp.PNG" width="406" height="304" class="tcecode">
</li>
</ol>
<br><br>
</li>
<li>
Where does the compiler keep track of all the scope and binding information about identifiers?<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Heap</li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> Symbol Table<br><span class="explanation">Explanation:</span><br>Compiler uses symbol table to keep track of scope and binding information about names. Symbol table is changed every time a name is encountered in the source; changes to table occur<br>•	if a new name is discovered<br>•	if new information about an existing name is discovered<br>Symbol table must have mechanism to:<br>•	add new entries<br>•	find existing information efficiently
</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Activation record</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Stack</li>
</ol>
<br><br>
</li>
<li>
Consider the grammar below:<br>E → UV | EBE | V | [E]<br>V → a | b<br>U → &lt; | &gt;<br>B → ? | ! | @<br>The CFG is eliminated of ambiguity, left recursion and left factors. Considering ?, !, @ as right associative binary operators and their precedence being assumed as ? having lowest precedence, followed by ! and @ having the highest. Unary operators &lt; and &gt; have even higher precedence. The resulting grammar is as follows:<br>E   → T <br>  → ? E | ∊<br>T   → F  <br>  → ! T | ∊<br>F   → W  <br>  → @F | ∊<br>W → UV | V | [E]<br>V  → a | b<br>U → &lt; | &gt;<br>	The FOLLOW sets for each non-terminal in the grammar is:<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> FOLLOW(E)   = {&lt;, &gt;, a, b}<br>FOLLOW( ) = {?, ∊}<br>FOLLOW(T)   = {&lt;, &gt;, a, b}<br>FOLLOW( ) = {!, ∊}<br>FOLLOW(F)   = {&lt;, &gt;, a, b, [}<br>FOLLOW( ) = {a, b}<br>FOLLOW(W) = {@, ∊}<br>FOLLOW(V) = {&lt;, &gt;}<br>FOLLOW(U) = {a, b}</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> None of these</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> FOLLOW(E)   = {$}<br>FOLLOW( ) = {$,]}<br>FOLLOW(T)   = {&lt;, &gt;, a, b}<br>FOLLOW( ) = {&lt;, &gt;, ∊}<br>FOLLOW(F)   = {!, ?, $, ]}<br>FOLLOW( ) = {!, ?, $, ]} <br>FOLLOW(W) = {@, !, ?, $, ]}<br>FOLLOW(V)  = {a, b}<br>FOLLOW(U)  = {&lt;, &gt;}</li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> FOLLOW(E)   = {$, ]}<br>FOLLOW( ) = {$,]}<br>FOLLOW(T)   = {?, $, ]}<br>FOLLOW( ) = {?, $, ]}<br>FOLLOW(F)   = {!, ?, $, ]}<br>FOLLOW( ) = {!, ?, $, ]} <br>FOLLOW(W) = {@, !, ?, $, ]}<br>FOLLOW(V)  = {@, !, ?, $, ]}<br>FOLLOW(U)  = {a, b}<br><span class="explanation">Explanation:</span><br><img src="./Test Results122_files/Q4_exp.PNG" alt="image:CD Subject Test - 3/Q4_exp.PNG" width="463" height="358" class="tcecode">
</li>
</ol>
<br><br>
</li>
<li>
The LL(1) parsing table for the modified grammar is given below:<br>E   → T <br>  → ? E | ∊<br>T   → F  <br>  → ! T | ∊<br>F   → W  <br>  → @F | ∊<br>W → UV | V | [E]<br>V  → a | b<br>U → &lt; | &gt;<br>	LL(1) parsing table:<br><img src="./Test Results122_files/Edit_1.png" alt="image:CD Subject Test - 3/Edit_1.png" width="754" height="365" class="tcecode"><br>What will be the value of entries E1, E2, E3, E4, E5 respectively?<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> <img src="./Test Results122_files/Q5_opt_C.PNG" alt="image:CD Subject Test - 3/Q5_opt_C.PNG" width="309" height="24" class="tcecode"></li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> <img src="./Test Results122_files/Q5_opt_B.PNG" alt="image:CD Subject Test - 3/Q5_opt_B.PNG" width="311" height="39" class="tcecode"></li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> E → TE',T'→!T, T'→∊,F→WF',U→∊<br><span class="explanation">Explanation:</span><br><img src="./Test Results122_files/Edit_2.png" alt="image:CD Subject Test - 3/Edit_2.png" width="752" height="349" class="tcecode">
</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> <img src="./Test Results122_files/Q5_opt_D.PNG" alt="image:CD Subject Test - 3/Q5_opt_D.PNG" width="295" height="32" class="tcecode"></li>
</ol>
<br><br>
</li>
<li>
Consider the following grammar:<br>E → UV | EBE | V | [E]<br>V → a | b<br>U → &lt; | &gt;<br>B → ? | ! | @<br>	Which of the following statement is incorrect?<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> The grammar is unambiguous<br><span class="explanation">Explanation:</span><br><span style="text-decoration:underline;">The grammar is unambiguous ⇒ incorrect.</span><br>The grammar is ambiguous. Expression “a @ a ! a” has the following two parse trees under the grammar.<br><img src="./Test Results122_files/Q3_exp.PNG" alt="image:CD Subject Test - 3/Q3_exp.PNG" width="365" height="249" class="tcecode">
</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> The grammar contains left recursion</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> The grammar can derive more than one parse trees for a given string</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> The grammar is a CFG</li>
</ol>
<br><br>
</li>
<li>
For the grammar:<br>S → Aa | bAc | dc | bda<br>A → d<br>	What will be the entries E1, E2, E3, E4 respectively in the CLR(1) / LALR(1) parsing table?<br><img src="./Test Results122_files/Q16.PNG" alt="image:CD Subject Test - 3/Q16.PNG" width="440" height="314" class="tcecode"><br>Note: The blank entries in the options is denoted as “_”<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> S<sub class="tcecode">11</sub>, r<sub class="tcecode">2</sub>, S<sub class="tcecode">11</sub>, _</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> 7, _, S<sub class="tcecode">5</sub>, r<sub class="tcecode">1</sub></li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> 7, S<sub class="tcecode">9</sub>, S<sub class="tcecode">10</sub>, r<sub class="tcecode">4</sub><br><span class="explanation">Explanation:</span><br>Consider augmented grammar:<br><img src="./Test Results122_files/Q16_exp_1.PNG" alt="image:CD Subject Test - 3/Q16_exp_1.PNG" width="133" height="160" class="tcecode"><br>Create cannonical collection of LR(1) items:<br><img src="./Test Results122_files/Q16_exp_2.PNG" alt="image:CD Subject Test - 3/Q16_exp_2.PNG" width="570" height="468" class="tcecode"><br><img src="./Test Results122_files/Edit_8.png" alt="image:CD Subject Test - 3/Edit_8.png" width="572" height="393" class="tcecode"><br>Looking at figure we can see, the states I5 and I8 contain final and non final items but there is no SR or RR conflict as lookahead in the final item is not the same as terminal next to dot in the non final item. So no conflicts. This grammar is an LR(1) grammar. There are no states differing by lookaheads, hence it is also LALR(1). The parsing table for CLR(1) and LALR(1) is as shown in table.<br>	This grammar is not LL(1), not LR(1), not SLR(1) but it is CLR(1) and LALR(1) grammar.       	<br>	CLR(1) / LALR(1) parsing table:
</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> _, S<sub class="tcecode">9</sub>, S<sub class="tcecode">10</sub>, r<sub class="tcecode">4</sub></li>
</ol>
<br><br>
</li>
<li>
Consider the following grammar:<br>S → Aa | bAc | dc | bda<br>A → d<br>	Given below is a partial cannonical collection of LR(1) items:	<br><img src="./Test Results122_files/Q15.PNG" alt="image:CD Subject Test - 3/Q15.PNG" width="448" height="321" class="tcecode">           <br>Find the value of missing states I4, I8    ?<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> I4: S → bAc ., $<br>I8: S → b . dw, $</li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> I4: S → b . Ac, $<br>     S → b . dw, $<br>     S → . d, c<br>I8: S → bd . w, $<br>     A → d . , c<br><span class="explanation">Explanation:</span><br>The partial canonical collection of LR(1) items is given below:<br><img src="./Test Results122_files/Edit_6.png" alt="image:CD Subject Test - 3/Edit_6.png" width="498" height="389" class="tcecode">
</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> I4: S → b . Ac, $<br>     S → b . da, $<br>I8: S → bd . a, $</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> I4: → . S, $<br>     S → b . Ac, $<br>     S → b . da, $<br>I8: S → Aw . , $</li>
</ol>
<br><br>
</li>
<li>
For the same expression consider the following statements regarding the three representations of it as three address code:<br>S1: Triples are inefficient representation since it does not give the freedom of moving the code.<br>S2: Out of all the three representations of 3-address code i.e., quadruples, triples and indirect triples, only indirect triples does not have any kind of disadvantage.<br>	Which one of the following is correct?<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Both S1 and S2</li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> Neither S1 nor S2<br><span class="explanation">Explanation:</span><br>We cannot say triples are an inefficient representation just because it does not allow freedom of moving the code. One of the advantages that triples provide is that a lot of space is not wasted compared to quadruples.<br>Also we cannot say that indirect triples does not have any kind of disadvantage as it involves two memory access:<br>→ We first have to go to the pointer for the instruction<br>→ The pointer then will point to the instruction.
</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Only S2</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Only S1</li>
</ol>
<br><br>
</li>
<li>
The triple representation for the following expression:<br>a = b* - (c – d) + b – (c – d)<br>	note that U represents unary minus.<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> <img src="./Test Results122_files/Q22_opt_C.PNG" alt="image:CD Subject Test - 3/Q22_opt_C.PNG" width="444" height="199" class="tcecode"></li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> None of these</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> <img src="./Test Results122_files/Q22_opt_A.PNG" alt="image:CD Subject Test - 3/Q22_opt_A.PNG" width="445" height="171" class="tcecode"></li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> <img src="./Test Results122_files/Q22_opt_B.PNG" alt="image:CD Subject Test - 3/Q22_opt_B.PNG" width="444" height="217" class="tcecode"><br><span class="explanation">Explanation:</span><br>In triples there are only three fields, one for the operation and the remaining two for operands that may have a variable or a constant or the statement position number that computes the value of the operand. Since there are only three fields, it is called “triples”.<br>Parenthesized numbers represent the position number of the triple structure, while symbol-table pointers are represented by the names themselves. Since the operands represent two different entries, the fields can be encoded in a proper manner. For example, in case of copy statement a:= t1, where t1 is computed at some position (i) then the triplet entries are “=” is placed in the first field, ‘a’ in the second field and (i) in the third field. For a ternary operation like a[i]:= b, it requires two entries in the structure. The first entry finds the position of i with reference to ‘a’ and then the actual copy <br>statement as given below:<br><img src="./Test Results122_files/Q22_exp.PNG" alt="image:CD Subject Test - 3/Q22_exp.PNG" width="616" height="372" class="tcecode">
</li>
</ol>
<br><br>
</li>
<li>
Consider we are going to convert the statement to three address code:<br>a = b* - (c – d) + b* - (c – d)<br>	Which one of the following represents appropriate three address code:<span style="float:right">( Marks: 0.00 )</span>
<ol class="answer">
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> Both (a) &amp; (b)</li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> <img src="./Test Results122_files/Q21_opt_C.PNG" alt="image:CD Subject Test - 3/Q21_opt_C.PNG" width="314" height="169" class="tcecode"></li>
<li>&nbsp;<img src="./Test Results122_files/wrong.png" width="16"> <img src="./Test Results122_files/Q21_opt_B.PNG" alt="image:CD Subject Test - 3/Q21_opt_B.PNG" width="314" height="146" class="tcecode"></li>
<li>&nbsp;<img src="./Test Results122_files/correct.png" width="18"> <img src="./Test Results122_files/Q21_opt_A.PNG" alt="image:CD Subject Test - 3/Q21_opt_A.PNG" width="312" height="246" class="tcecode"><br><span class="explanation">Explanation:</span><br>A quadruple is a record structure with four fields. The first field is to store the operator. The second and third fields are for the operands used in the operation, and the fourth field is for the result. For example, the three address statement A = B op C is written by placing op in the first field, that is operator, B and C are placed in the second and third fields, that is, operand 1 and operand 2 respectively, and A in fourth field, that is, result. If the operator is unary, then the third field is not used.	<br><img src="./Test Results122_files/Q21_exp.PNG" alt="image:CD Subject Test - 3/Q21_exp.PNG" width="311" height="245" class="tcecode">
</li>
</ol>
<br><br>
</li>
</ol>
</div>
</div>
<a href="http://gatexcel.co.in/public/code/index.php" title="Main Page"><strong>&lt; Back To Home</strong></a>
</div>

</div>

<div class="userbar">
<span class="copyright">© 2017 - Raudra</span></div>

<div tabindex="-1" role="dialog" class="ui-dialog ui-corner-all ui-widget ui-widget-content ui-front ui-draggable" aria-describedby="data-dialog" style="display: none;" aria-labelledby="ui-id-1"><div class="ui-dialog-titlebar ui-corner-all ui-widget-header ui-helper-clearfix ui-draggable-handle"><span id="ui-id-1" class="ui-dialog-title">Data</span><button type="button" class="ui-button ui-corner-all ui-widget ui-button-icon-only ui-dialog-titlebar-close" title="Close"><span class="ui-button-icon ui-icon ui-icon-closethick"></span><span class="ui-button-icon-space"> </span>Close</button></div><div id="data-dialog" class="ui-dialog-content ui-widget-content">
    <div>
    <img src="./Test Results122_files/usefulDataFile_1.jpg">
    </div>
<!--    <table border="1" class="data-table">
        <tr>
            <th>Constant</th>
            <th>Symbol</th>
            <th>Value</th>
        </tr>
        <tr>
            <td>speed of light in vacuum</td>
            <td>c</td>
            <td>3.00 X 10<sup>8</sup> ms<sup>-1</sup></td>
        </tr>
        <tr>
            <td>gravitational constant</td>
            <td>G</td>
            <td>6.673 X 10<sup>-11</sup> Nm<sup>2</sup>kg<sup>-2</sup> </td>
        </tr>
        <tr>
            <td>orbital Constant</td>
            <td>G M<sub>E</sub></td>
            <td>3.986 X 10<sup>14</sup> m<sup>3</sup>s<sup>-2</sup></td>
        </tr>
        <tr>
            <td>standard gravitational acceleration</td>
            <td>g</td>
            <td>9.81 m s<sup>-1</sup></td>
        </tr>
        <tr>
            <td>Planck's constant</td>
            <td>h</td>
            <td>6.626 X 10<sup>-34</sup> J s</td>
        </tr>
        <tr>
            <td>Boltzmann's constant</td>
            <td>k</td>
            <td>1.381 X 10 <sup>-23</sup> J K  <sup>-1</sup></td>
        </tr>
        <tr>
            <td>first radiation constant</td>
            <td>c<sub>1</sub></td>
            <td>1.191 X 10<sup>-16</sup> W m<sup>2</sup>sr<sup>-1</sup></td>
        </tr>
        <tr>
             <td>second radiation constant</td>
            <td>c<sub>2</sub></td>
            <td>1.439 X 10<sup>-2</sup>mK</td>
        </tr>
        <tr>
             <td>Stefan-Boltzmann constant</td>
            <td></td>
            <td>5.670 X 10<sup>-8</sup> W m<sup>-2</sup> K <sup>-4</sup></td>
        </tr>
         <tr>
            <td></td>
            <td>none</td>
            <td>5.670 X 10<sup>-8</sup> W m<sup>-2</sup> K <sup>-4</sup></td>
        </tr>
    </table>-->
</div></div><div tabindex="-1" role="dialog" class="ui-dialog ui-corner-all ui-widget ui-widget-content ui-front ui-draggable" aria-describedby="dialog" aria-labelledby="ui-id-2" style="display: none;"><div class="ui-dialog-titlebar ui-corner-all ui-widget-header ui-helper-clearfix ui-draggable-handle"><span id="ui-id-2" class="ui-dialog-title">Instructions</span><button type="button" class="ui-button ui-corner-all ui-widget ui-button-icon-only ui-dialog-titlebar-close" title="Close"><span class="ui-button-icon ui-icon ui-icon-closethick"></span><span class="ui-button-icon-space"> </span>Close</button></div><div id="dialog" class="ui-dialog-content ui-widget-content">
    <div class="instruction-heading"><b>Please read the instruction carefully</b></div>
    <b><u>General Instructions during the Examination</u></b>
    <ol>
        <li>Total duration of the examination is 45 minutes.
        </li>
        <li>The Question Palette displayed on the right side of screen will show the status of each question using one of the following coloured boxes:
            <ul class="instruction-tips">
                <li>
                    <span class="white">15</span> You have not visited the question yet.
                </li>
                <li>
                    <span class="grey">45</span> You are reading current question.
                </li>
                <li>
                    <span class="red">40</span> You have visited the question but you have not the answered the question.
                </li>
                <li>
                    <span class="green">10</span> You have answered the question.
                </li>
            </ul>
        </li>
    </ol>
    <b><u>Navigating to Questions</u></b>
    <ol>
        <li>You can navigate to any answer by clicking on the number in question panel on the right side.</li>
        <li>To go to next question click <b>Next</b> button and to go to previous question click <b>Previous</b> button. These buttons are located at the bottom of each question</li>
    </ol>
    <b><u>Answering a Question</u></b>
    <ol>
        <li>To answer the question select any of the option and then select <b>Confirm</b> button to confirm answer.</li>
        <li>To terminate the exam write the comment in the comment box and click <b>Terminate the exam</b> button.</li>
    </ol>
    <ol>Multiple choice type questions will have four choices against A, B, C, D, out of which only ONE is the correct answer. The candidate has to choose the correct answer by clicking on the
        bubble (⃝) placed before the choice.</ol>
    <ol> In this paper a candidate can answer a total of 15 questions carrying 25 marks. Out of which, 5 questions carrying 1 mark each and 10 questions carrying 2 marks each. All questions are
        Multiple Choice Questions (MCQ).</ol>
    <ol>All questions that are not attempted will result in zero marks. However, wrong answers will result in NEGATIVE marks. For all questions a wrong answer will result in deduction of 0.33 marks for a 1 mark question and 0.66 for a 2 mark question.</ol>
    <ol>You can click on Terminate the exam to submit your responses and end the examination.</ol>
    <strong>ALL THE BEST!!!</strong>
</div></div></body></html>